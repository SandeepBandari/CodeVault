my new task is : i have created front end using JS upto retrieving elements and UI, not performing operations through JS, for operations i did in springboot as backend, so now i want to save the history in browser context without retrieving from database and conditions are without integration of front end and backend,and i want to implement by just doing operations at backend without using front end so give me according to it. i will give my backend codes. package com.example.Calculator; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping("/calculator") public class C_controller { private static final Logger logger = LoggerFactory.getLogger(C_controller.class); @Autowired Calculation service; @PostMapping("/{operationtype}") public ResponseEntity<CalculationEntity> m1(@PathVariable String operationtype,@RequestParam double value1,@RequestParam double value2) throws Exception { logger.info("Post request received for operation:{},value1:{},value2:{}",operationtype,value1,value2); CalculationEntity results=service.operation(operationtype,value1,value2); logger.info("Operation result: {}", results); return ResponseEntity.ok(results); } @GetMapping("/{operationtype}") public ResponseEntity <CalculationEntity> m1Get(@PathVariable String operationtype, @RequestParam double value1, @RequestParam double value2) throws Exception { logger.info("GET request received for operation: {}, value1: {}, value2: {}", operationtype, value1, value2); CalculationEntity results=service.operation(operationtype, value1, value2); logger.info("Operation result: {}", results); return ResponseEntity.ok(results); } @ExceptionHandler(InvalidException.class) public ResponseEntity<String>handleInvalidException(InvalidException e) { logger.error("InvalidException occurred: {}", e.getMessage()); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage()); } }package com.example.Calculator; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class Calculation { private static final Logger logger=LoggerFactory.getLogger(Calculation.class); @Autowired CalculatorRepository repository; public CalculationEntity operation(String operationtype,double value1,double value2) throws Exception { logger.info("Performing operation:{} with value1:{} and value2:{}",operationtype,value1,value2); double result; if(operationtype.equalsIgnoreCase("add")) { result=value1+value2; logger.debug("Addition result:{}",result); } else if(operationtype.equalsIgnoreCase("sub")) { result=value1-value2; logger.debug("Substraction result:{}",result); } else if(operationtype.equalsIgnoreCase("mul")) { result=value1*value2; logger.debug("Multiplication result:{}",result); } else if(operationtype.equalsIgnoreCase("div")) { if(value2 !=0) { result=value1/value2; logger.debug("Division result:{}",result); } else { logger.error("Division by zero attempted with value1: {}", value1); throw new InvalidException("invalid value1"); } } else if(operationtype.equalsIgnoreCase("modulus")) { result=value1%value2; } else { throw new InvalidException("Invalid operation"); } CalculationEntity ce=new CalculationEntity(value1,value2,operationtype,result); logger.info("Saving result to database: {}", ce); return repository.save(ce); } } class InvalidException extends Exception { public InvalidException(String e) { super(e); } } package com.example.Calculator; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; @Entity public class CalculationEntity { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int s_no; private double value1; private double value2; private String operationtype; private double result; public CalculationEntity() { } public CalculationEntity(double value1, double value2,String operationtype,double result) { this.value1 = value1; this.value2 = value2; this.operationtype = operationtype; this.result = result; } public int getS_no() { return s_no; } public void setS_no(int s_no) { this.s_no = s_no; } public double getValue1() { return value1; } public void setValue1(double value1) { this.value1 = value1; } public double getValue2() { return value2; } public void setValue2(double value2) { this.value2 = value2; } public String getOperationtype() { return operationtype; } public void setOperationtype(String operationtype) { this.operationtype = operationtype; } public double getResult() { return result; } public void setResult(double result) { this.result = result; } } spring.datasource.url=jdbc:mysql://localhost:3306/Calculator_DB spring.datasource.username=root spring.datasource.password=7093885694 spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true # Set the root logging level logging.level.root=INFO # Set the logging level for specific packages logging.level.org.springframework=WARN logging.level.com.example=DEBUG # Log to a file logging.file.name=app.log logging.file.path=C:/Users/sande/Downloads/Calculator/Calculator/log/app.log # Custom log pattern logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n logging.level.org.springframework.orm.jpa=DEBUG logging.level.org.springframework.transaction=DEBUG logging.level.org.hibernate.SQL=DEBUG logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE package com.example.Calculator; import org.springframework.data.jpa.repository.JpaRepository; public interface CalculatorRepository extends JpaRepository<CalculationEntity,Integer> { } package com.example.Calculator; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Calculator_Main { private static final Logger logger=LoggerFactory.getLogger(Calculator_Main.class); public static void main(String[] args) { logger.info("Calculator app is Going to Start"); SpringApplication.run(Calculator_Main.class, args); logger.info("Calculator app is Started Successfully."); } }
Got it! You want to save the history of calculations in the browser context using JavaScript without integrating the frontend and backend. You can use the browser's localStorage or sessionStorage for this purpose. Here's a step-by-step approach to achieve this:

Store Calculation History in Browser: Use JavaScript to save the history locally in the browser. You can save each calculation result along with the operation details.

Retrieve and Display History: Retrieve the stored history from localStorage or sessionStorage and display it in the UI.

Here's an example implementation:

Frontend (JavaScript)
Save History to localStorage:

javascript
function saveCalculationToLocalStorage(operation, value1, value2, result) {
    let history = JSON.parse(localStorage.getItem("calculationHistory")) || [];
    history.push({ operation, value1, value2, result, timestamp: new Date().toISOString() });
    localStorage.setItem("calculationHistory", JSON.stringify(history));
}

function displayHistory() {
    let history = JSON.parse(localStorage.getItem("calculationHistory")) || [];
    let historyContainer = document.getElementById("historyContainer");
    historyContainer.innerHTML = ""; // Clear existing history

    history.forEach(entry => {
        let entryElement = document.createElement("div");
        entryElement.textContent = `${entry.timestamp}: ${entry.value1} ${entry.operation} ${entry.value2} = ${entry.result}`;
        historyContainer.appendChild(entryElement);
    });
}

// Call displayHistory on page load
window.onload = displayHistory;
Backend (Spring Boot)
Assuming your backend is already set up to handle calculation operations, you just need to ensure that the frontend sends requests and handles responses correctly.

Example HTML Structure
html
<!DOCTYPE html>
<html>
<head>
    <title>Calculator</title>
    <script src="path/to/your/script.js"></script>
</head>
<body>
    <div id="calculator">
        <input type="number" id="value1" placeholder="Value 1">
        <select id="operation">
            <option value="add">+</option>
            <option value="sub">-</option>
            <option value="mul">*</option>
            <option value="div">/</option>
            <option value="modulus">%</option>
        </select>
        <input type="number" id="value2" placeholder="Value 2">
        <button onclick="performCalculation()">Calculate</button>
    </div>
    <div id="result"></div>
    <div id="historyContainer"></div>
</body>
</html>
JavaScript to Perform Calculation and Save History
javascript
function performCalculation() {
    let value1 = parseFloat(document.getElementById("value1").value);
    let operation = document.getElementById("operation").value;
    let value2 = parseFloat(document.getElementById("value2").value);

    let request = new XMLHttpRequest();
    request.open('POST', `/calculator/${operation}`, true);
    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    request.onreadystatechange = function () {
        if (request.readyState === 4 && request.status === 200) {
            let response = JSON.parse(request.responseText);
            document.getElementById("result").textContent = `Result: ${response.result}`;
            saveCalculationToLocalStorage(operation, value1, value2, response.result);
            displayHistory();
        }
    };
    request.send(`value1=${value1}&value2=${value2}`);
}
With these steps, you'll be able to save the calculation history in the browser context without retrieving it from the database. The frontend handles the storage and retrieval of the history using localStorage. This allows you to keep the frontend and backend decoupled while still storing and displaying the history.